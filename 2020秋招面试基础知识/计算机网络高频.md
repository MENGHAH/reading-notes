> 1. [计算机网络太难？了解这一篇就够了](https://zhuanlan.zhihu.com/p/84316213)
> 2. [【面试题总结】计算机网络面试总结](http://yyanghhu.tech/2020/05/12/network-001/)
> 3. https://blog.csdn.net/chenchaofuck1/article/details/51980794

## 1. 五层协议

**应用层，运输层，网络层，数据链路层，物理层**

- 第五层——应用层(application layer) 

  - **应用层(application layer)：**是体系结构中的最高。<font color=blue>直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务</font>。
  - 在因特网中的应用层协议很多，如支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议，DNS，POP3，SNMP，Telnet等等。

- 第四层——运输层(transport layer)

  - **运输层(transport layer)：**<font color=blue>负责向两个主机中进程之间的通信提供服务</font>。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能
  - 复用，就是多个应用层进程可同时使用下面运输层的服务。
  - 分用，就是把收到的信息分别交付给上面应用层中相应的进程。
  - **运输层主要使用以下两种协议：** 
    **(1) 传输控制协议TCP(Transmission Control Protocol)：**面向连接的，数据传输的单位是报文段，能够提供可靠的交付。 
    **(2) 用户数据包协议UDP(User Datagram Protocol)：**无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。

- 第三层——网络层(network layer)

  - 网络层(network layer)主要包括以下两个任务：

    ​	**(1) <font color=blue>负责为分组交换网上的不同主机提供通信服务</font>。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报。**

    ​	**(2) <font color=blue>选中合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机</font>。**

  - **协议：IP,ICMP,IGMP,ARP（根据IP地址通过广播寻求MAC地址）,RARP**

- 第二层——数据链路层(data link layer)

  > <font color=blue>数据链路层的作用就是把IP数据报封装成帧，并实现相邻结点之间数据传输</font>

  - **数据链路层(data link layer)：**常简称为链路层，我们知道，两个主机之间的数据传输，总是在一段一段的链路上传送的，也就是说，<font color=blue>在两个相邻结点之间传送数据</font>是直接传送的(点对点)，这时就需要使用专门的链路层的协议。

  - 在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧(framing)，在两个相邻结点之间的链路上“透明”地传送帧中的数据。

  - 每一帧包括数据和必要的控制信息(如同步信息、地址信息、差错控制等)。典型的帧长是几百字节到一千多字节。

    > 注：”透明”是一个很重要的术语。它表示，某一个实际存在的事物看起来却好像不存在一样。”在数据链路层透明传送数据”表示无力什么样的比特组合的数据都能够通过这个数据链路层。因此，对所传送的数据来说，这些数据就“看不见”数据链路层。或者说，数据链路层对这些数据来说是透明的。 
    > (1)在接收数据时，控制信息使接收端能知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提取出数据部分，上交给网络层。 

  > (2)控制信息还使接收端能检测到所收到的帧中有无差错。如发现有差错，数据链路层就简单地丢弃这个出了差错的帧，以免继续传送下去白白浪费网络资源。如需改正错误，就由运输层的TCP协议来完成。

- 第一层——物理层(physical layer)

  - **物理层(physical layer)：**在物理层上所传数据的单位是比特。物理层的任务就是透明地<font color=blue>传送比特流</font>。

**各个层的作用是什么**

- 应用层：直接为用户的应用进程提供服务
- 传输层：为不同主机上的两个进程提供通信服务
- 网络层：1) 为分组交换网中的不同主机提供通信服务；2)选中合适的路由，使得源主机上通过运输成传下来的数据可以经过网路中的路由到达正确的目的主机
- 数据链路层：把IP数据包封装成帧并实现相邻结点之间的传输
- 物理层：传输比特流



## 2. 为什么有TCP的存在

因为IP通信时不可靠的，IP只为上层提供无状态、无连接、不可靠的服务。只保证尽力的交付，并且交付的数据是无序的并且还可能是重复的，也可能丢失。对于接受端的IP模块只要收到了完整的IP数据报就会将其数据部分交付给上层协议，所以如果不经过TCP的处理，应用层直接获取这样的数据是有问题的。所以TCP的存在时有必要的。TCP可以通过序列号确认、超时重传、流量控制、拥塞避免等保证数据的可靠交付。



## 3. TCP和UDP的区别

**1) 区别：**

-  连接
   TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。
   UDP无连接。

-  服务对象
   TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；
   UDP支持一对一，一对多，多对一，多对多的交互通信。

-  可靠性
   TCP是可靠交付：无差错，不丢失，不重复，按序到达。
   UDP是尽最大努力交付，不保证可靠交付。

-  拥塞控制，流量控制
   TCP有拥塞控制和流量控制保证数据传输的安全性。
   UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。
-  开销
   TCP的开销比价大，UDP的开销比较小



**2) TCP对应的协议和UDP对应的协议**
**TCP对应的协议：**

- FTP：定义了文件传输协议，使用21端口。
- Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。
- SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。
- POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。
- HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。

**3) UDP对应的协议：**

- DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
- SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
- TFTP(Trivial File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。

## 4. TCP三次握手/四次握手

**三次握手**：

- 第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；

- 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；

- 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

  > 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。

  ![img](https://pic2.zhimg.com/80/v2-1c5da3391ad30aa7aa30f9362407a77f_1440w.jpg)



**四次握手**

与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。

- 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。
- 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。
- 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
- 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

![img](https://pic3.zhimg.com/80/v2-dc0bdc69237df055ff8c2aa477887237_1440w.jpg)

**TIME-WAIT存在的含义：**

C向S发送的最后一个ACK有可能会丢失，这个时候S会再次向C发送一个FIN，如果C已经关闭，S会重复向C发送FIN，这就导致了资源的浪费，但是如果这个TIME-WAIT存在的话，即使最后一个C向S发送的ACK丢失，导致S再次发送FIN， 也会使得C和S之间的链接能够正常断开

### 1. TCP是如何保证可靠传输的

- 校验和

  发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。

- 确认应答+序列号

  TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。

- 超时重传

  当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

- 连接管理

- 流量控制

  TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。接收方有即时窗口（滑动窗口），随ACK报文发送 。

- 拥塞控制

  当网络拥塞时，减少数据的发送。

  > **慢启动、拥塞避免、快速重传、快速恢复**

### 2.  建立TCP 服务器的系统调用

> 1. [建立TCP 服务器的系统调用](https://blog.csdn.net/qq_37964547/article/details/81429627)

![这里写图片描述](https://img-blog.csdn.net/20180804211807158?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTY0NTQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



- accept只是从监听队列中取出链接，而不论链接处于何种状态，更不关心网络的变化

- ```C++
  recv(int socketfd, void* buf, size_t len, int flags)// 读取socketfd上的数据
  send(int socketfd, const void *buf, size_t len, int flags); // 往socketfd上写入数据
  ```

### 3. 超时重传

<font color=blue>当发生数据包丢失或者确认应答丢失时会触发超时重传机制</font>

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeuicRMlA8rKvl5AVLibhibDhgObdlvOJianvD0oj586rMc8wVs4hlzUtgRibWfD0WBpAJhRtHxOPd9ibibQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

超时时间一般设置为2个RTT时间，当超时时间设置的标准不同时会发生的情况

- 当超时时间 **RTO 较大**时，重发就慢，丢了老半天才重发，没有效率，性能差；
- 当超时时间 **RTO 较小**时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。

根据上述的两种情况，**超时重传时间 RTO 的值应该略大于报文往返  RTT 的值**。



### 4. 快速重传

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeuicRMlA8rKvl5AVLibhibDhggRhxrfiaRIsia0z3T4l7TxVM7J9vjFktFRKHkdva953UY6vFIpsYsOicQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

在上图，发送方发出了 1，2，3，4，5 份数据：

- 第一份 Seq1 先送到了，于是就 Ack 回 2；
- 结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；
- 后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；
- **发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。**
- 最后，接收到收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。

所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。

快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是<font color=blue>**重传的时候，是重传之前的一个，还是重传所有的问题。**</font>比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。



**4.1 SACK方法解决上述问题**

这种方式需要在 TCP 头部「选项」字段里加一个 `SACK` 的东西，它**可以将缓存的地图发送给发送方**，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以**只重传丢失的数据**。

如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 `SACK` 信息发现只有 `200~299` 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeuicRMlA8rKvl5AVLibhibDhg3RbEZItSOQY1TadJpUTuibIDziaibALaEmk7JO0Ill7iaeiaGI94Wyia0NXA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**4.2 D-SACK**

Duplicate SACK 又称 `D-SACK`，其主要**使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。**



### 5. 流量控制

> 流量控制是针对端到端的，也就是针对客户端发送和服务端接收的速度控制的机制，以避免客户端发送的太快，而服务端接受的太慢，导致问题的出现

TCP 利用滑动窗口实现流量控制。**流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率**。将窗口字段设置为 0，则发送方不能发送数据。

**滑动窗口**：

TCP 利用滑动窗口实现流量控制的机制。**滑动窗口（Sliding window）是一种流量控制技术**。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。

TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。

### 6. 拥塞控制

> <font color=blue>说一下什么是拥塞控制</font>
>
> <font color=blue>拥塞控制主要是作用于网络，防止过多地数据被注入到网络，避免出现网络负载过大的情况。在C/S模型中，发送方维持一个叫做拥塞窗口cwnd（congestion window）。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方可以让自己的发送窗口等于拥塞窗口，但是考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。常用的方法包括慢开始、拥塞避免、快重传、快恢复。</font>

![图片说明](https://uploadfiles.nowcoder.com/images/20200826/498663897_1598422806100_85D3125CBCFE4357921CDD910EA780D5)



> 拥塞控制是针对网络的，当计算过多时，网络可能会出现拥堵，这个时候发送方应该如何让发送数据。这就利用到了拥塞控制。

拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。

**拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致于过载**。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，**流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收**。

为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。**发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个**。

TCP 的拥塞控制采用了四种算法，即：**慢开始、拥塞避免、快重传和快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略，以减少网络拥塞的发生。

- **慢开始**

  最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，避免cwnd增长过大。

- **拥塞避免**

  每经过一个往返时间RTT，cwnd就增长1。在慢开始和拥塞避免的过程中，一旦发现网络拥塞，就把慢开始门限设为当前值的一半，并且重新设置cwnd为1，重新慢启动。（乘法减小，加法增大）

- **快重传**

  接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。

- **快恢复**

  当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），将当前的cwnd设置为慢开始门限，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。



<font color=blue>**6.1 发送端如何判断拥塞发生**</font>

- 发生超时重传
- 接收到重复确认的报文段

### 7. TCP为什么采用三次握手，而非两次

考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。

### 8. UDP要想实现可靠传输如何实现

因为UDP是无连接的协议，所以在传输层上无法保证可靠传输，要想实现可靠传输，只能从应用层实现。需要实现seq/ack机制，重传机制和窗口确认机制就要接收方收到UDP之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。

### 9. TCP相关开放性问题

#### 9.1 TCP性能瓶颈

当连续接受三个重复的ACK时，发生超时重传，这时候发送端的发送窗口就会阻塞，不能向右继续滑动，也就限制了后面的数据的发送。这就是TCP的性能瓶颈。

> 如何解决？
>
> 使用QUIC技术解决TCP性能瓶颈问题

#### 9.2 TCP连接文件描述符耗尽怎么办

- 客户端最大tcp连接数位65536 - 1 = 65535 port 0 特殊含义
- 服务器的最大tcp连接数， {local ip, local port,remote ip,remote port}
- server最大tcp连接数：server通常固定在某个本地端口上监听，等待client的连接请求。不考虑地址重
  用（unix的SO_REUSEADDR选项）的情况下，即使server端有多个ip，本地监听端口也是独占的，因此
  server端tcp连接4元组中只有remote ip（也就是client ip）和remote port（客户端port）是可变的，
  因此最大tcp连接为客户端ip数×客户端port数，对IPV4，不考虑ip地址分类等因素，最大tcp连接数约为
  2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。
  当系统的文件描述符耗尽的时候，我们要做一些处理：
  - **方式一：**在拿到大于或者等于0的connfd(连接文件描述符)之后，非阻塞的epoll/select一下，看看这个fd是否可写。正常情况下epoll/select会返回writable，表明connfd可用。如果epoll/select返回错误，表示这个fd有问题，应该立刻关闭连接
  - **方式二：**设置一个最大连接数，当连接超过设定值时，直接关闭当前这个fd 

#### 9.3 TCP的7种定时器

> 1. 建立连接定时器(connection-establishment timer)
> 2. 重传定时器(retransmission timer)
> 3. 延迟应答定时器(delayed ACK timer)
> 4. 坚持定时器(persist timer)
> 5. 保活定时器(keepalive timer)
> 6. FIN_WAIT_2定时器(FIN_WAIT_2 timer)
> 7. TIME_WAIT定时器 (TIME_WAIT timer, 也叫2MSL timer) 

**1. 建立连接定时器**

TCP三次握手的时候，客户端先发送一个SYN请求建立连接，但是这个SYN可能会丢失。如果SYN包丢失了， 那么3秒以后会重新发送SYN包的(当然还会启动一个新的定时器， 设置成6秒超时) 

**2. 重传定时器**

重传定时器在TCP发送数据时设定，在计时器超时后没有收到返回的确认ACK，发送端就会重新发送队列中需要重传的报文段 。

**3. 延迟应答计时器**

延迟应答也被成为捎带ACK， 这个定时器是在延迟应答的时候使用的。 为什么要延迟应答呢？ 延迟应答是为了提高网络传输的效率。
举例说明，比如服务端收到客户端的数据后， 不是立刻回ACK给客户端， 而是等一段时间(一般最大200ms)，这样如果服务端要是有数据需要发给客户端，那么这个ACK就和服务端的数据一起发给客户端了， 这样比立即回给客户端一个ACK节省了一个数据包。 

**4. 坚持定时器**

我们已经知道TCP通过让接收方指明希望从发送方接收的数据字节数（即窗口大小）来进行流量控制。如果窗口大小为 0会发生什么情况呢？这将有效地阻止发送方传送数据，直到窗口变为非0为止。接收端窗口变为非0后，就会发送一个确认ACK指明需要的报文段序号以及窗口大小。
如果这个确认ACK丢失了，则双方就有可能因为等待对方而使连接终止：接收方等待接收数据（因为它已经向发送方通告了一个非0的窗口），而发送方在等待允许它继续发送数据的窗口更新。为防止这种死锁情况的发生，发送方使用一个坚持定时器 (persist timer)来周期性地向接收方查询，以便发现窗口是否已增大。这些从发送方发出的报文段称为窗口探查 (window probe)。 

**5. 保活定时器**

如果长时间客户端和服务端没有数据交换，那么就需要验证这个TCP链接是否还需要继续保持，那么就设定一个定时器，超时就认为TCP链接可以断开了。真正的实现还是需要自己实现心跳包

**6. FIN_WAIT_2**

**7. TIME_WAIT**

主要是为了保证TCP可以正常完成挥手的过程。在最后客户端向服务端发送ACK的时候，有可能会因为网络延迟或者丢失导致服务端重发FIN来断开TCP连接，这个时候如果客户端已经关闭，那么就会造成服务端不断的发送FIN，这就造成了服务器的资源浪费。



#### 9.4 TCP通信中可能出现的异常问题

##### 01 试图与一个不存在的端口建立连接

服务器端口还没有监听，我们的客户端就调用connect，试图与其建立连接。这是会发生什么呢？没
错，这符合触发发送**RST**分节的条件，目的为某端口的SYN分节到达，而端口没有监听，那么内核会立
即响应一个RST，表示出错。客户端TCP收到这个RST之后则放弃这次连接的建立，并且返回给应用程序
一个错误。正如上面所说的，建立连接的过程对应用程序来说是不可见的，这是操作系统帮我们来完成
的，所以即使进程没有启动，也可以响应客户端。

##### 02 试图与一个不存在的主机上面的某端口建立连接

这也是一种比较常见的情况，当某台服务器主机宕机了，而客户端并不知道，仍然尝试去与其建立连
接。根据上面的经验，这次主机已经处于未启动状态，操作系统也帮不上忙了，那么也就是连RST也不
能响应给客户端，此时服务器端是一种完全没有响应的状态。那么此时客户端的TCP会怎么办呢？据书
上介绍，如果客户端TCP没有得到任何响应，那么等待6s之后再发一个SYN，若无响应则等待24s再发一
个，若总共等待了75s后仍未收到响应就会返回ETIMEDOUT错误。这是TCP建立连接自己的一个保护机
制，但是我们要等待75s才能知道这个连接无法建立，对于我们所有服务来说都太长了。更好的做法是
在代码中给connect设置一个超时时间，使它变成我们可控的，让等待时间在毫秒级还是可以接收的。

##### 03 Server进程被阻塞

由于某些情况，服务器端进程无法响应任何请求，比如所在主机的硬盘满了，导致进程处于完全阻塞，
通常我们测试时会用gdb模拟这种情况。上面提到过，建立连接的过程对应用程序是不可见的，那么，
这时连接可以正常建立。当然，客户端进程也可以通过这个连接给服务器端发送请求，服务器端TCP会
应答ACK表示已经收到这个分节（这里的收到指的是数据已经在内核的缓冲区里准备好，由于进程被阻
塞，无法将数据从内核的缓冲区复制到应用程序的缓冲区），但永远不会返回结果。

##### 04 我们杀死server

这是线上最常见的操作，当一个模块上线时，OP同学总是会先把旧的进程杀死，然后再启动新的进程。那么在这个过程中TCP连接发生了什么呢。在进程正常退出时会自动调用close函数来关闭它所打开的文件描述符，这相当于服务器端来主动关闭连接——会发送一个FIN分节给客户端TCP；客户端要做的就是配合对端关闭连接，TCP会自动响应一个ACK，然后再由客户端应用程序调用close函数，也就是我们上面所描述的关闭连接的4次挥手过程。接下来，客户端还需要定时去重连，以便当服务器端进程重新启动好时客户端能够继续与之通信。

当然，我们要保证客户端随时都可以响应服务器端的断开连接请求，就必须不能让客户端进程再任何时刻阻塞在任何其他的输入上面。比如，书上给的例子是客户端进程会阻塞在标准输入上面，这时如果服务器端主动断开连接，显然客户端不能立刻响应，因为它还在识图从标准输入读一段文本……当然这在实际中很少遇到，如果有多输入源这种情况的话开通通常会用类似select功能的函数来处理，可以同时监控多个输入源是否准备就绪，可以避免上述所说的不能立即响应对端关闭连接的情况。

##### 05 Server进程所在的主机关机

实际上这种情况不会带来什么更坏的后果。在系统关闭时，init进程会给所有进程发送SIGTERM信号，等待一段时间（5~20秒），然后再给所有仍在运行的进程发送SIGKILL信号。当服务器进程死掉时，会关闭所有文件描述符。带来的影响和上面杀死server相同。

##### 06 Server进程所在的主机宕机

这是我们线上另一种比较常见的状况。即使宕机是一个小概率事件，线上几千台服务器动不动一两台挂
掉也是常有的事。主机崩溃不会像关机那样会预先杀死上面的进程，而是突然性的。那么此时我们的客
户端准备给服务器端发送一个请求，它由write写入内核，由TCP作为一个分节发出，随后客户阻塞于
read的调用（等待接收结果）。对端TCP显然不会响应这个分节，因为主机已经挂掉，于是客户端TCP
持续重传分节，试图从服务器上接收一个ACK，然而服务器始终不能应答，重传数次之后，大约4~10分
钟才停止，之后返回一个ETIMEDOUT错误。
这样尽管最后还是知道对方不可达，但是很多时候我们希望比等待4~10分钟更快的知道这个结果。可以
为read设置一个超时时间，就得到了一个较好的解决方法。但是这样还是需要等待一个超时时间，事实
上TCP为我们提供了更好的方法，用SO_KEEPALIVE的套接字选项——相当于心跳包，每隔一段时间给
对方发送一个心跳包，当对方没有响应时会一更短的时间间隔发送，一段时间后仍然无响应的话就断开
这个连接。

##### 07 服务器进程所在的主机宕机后重启

在客户端发出请求前，服务器端主机经历了宕机——重启的过程。当客户端TCP把分节发送到服务器端
所在的主机，服务器端所在主机的TCP丢失了崩溃前所有连接信息，即TCP收到了一个根本不存在连接
上的分节，所以会响应一个RST分节。如果开发的代码足够健壮的话会试图重新建立连接，或者把这个
请求转发给其他服务器。

#### 9.5 close和shutdown的区别

- shutdown()函数可以选择关闭全双工连接的读通道或者写通道；close()是关闭全双工连接的读写通道，也就是关闭连接；

- close()函数会释放套接字占用的文件描述符，而shutdown()不会释放占用的文件描述符。

  > 所以即使调用shutdown()关闭连接，也仍然要调用close()来释放连接占用的文件描述符。调用close()后将该socket的文件描述符减一，如果为0，就释放文件占用的内存。 

## 5. 各种协议介绍

- ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。
- TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。
- HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。
- NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，
- DHCP协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段，使用UDP协议工作。具体用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。






## 6. 路由器、网关、交换机的用途

1）交换机
在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。
交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。
交换机被广泛应用于二层网络交换，俗称“二层交换机”。
交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。

2）路由器
路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。
路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。

3）网关
网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。
在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。
在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。
网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关还原成模拟的电话信号，最后才能在电话机上听到。
对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。

**总结**
**1. 交换机的作用：**交换机只有转发的功能，他的每个端口并不具有MAC地址，但是他的内部保存了一张MAC缓存表，每一个接口对应的MAC地址会保存在表里，当有数据来了以后，先查找MAC缓存表是否有对应的接口，如果有直接向这个端口转发，如果没有就通过广播的方式来查找哪个端口对应着目标MAC地址，查到后转发数据并把MAC地址对应的端口放到MAC缓存表里面。<font color=blue>**MAC 头部的作用就是将包送达路由器**</font>

**2. 路由器的作用：**
在网络包传输的过程中，**源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址**，因为需要 MAC 地址在以太网内进行**两个设备**之间的包传输。

## 7. 什么是粘包

可能会发现：如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。

1. TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界；
2. 从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段。

基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。

接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。

## 8. TCP 黏包是怎么产生的？

- **发送方产生粘包**

采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。

- **接收方产生粘包**

接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 > 应用层拿数据速度）

## 9.  怎么解决拆包和粘包？

分包机制一般有两个通用的解决方法：

1. 特殊字符控制；
2. 在包头首都添加数据包的长度。

如果使用 netty 的话，就有专门的编码器和解码器解决拆包和粘包问题了。

tips：UDP 没有粘包问题，但是有丢包和乱序。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是 UDP 报文或用户数据报，发送的时候既不合并，也不拆分。

## 10. 什么是数字签名？

为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如 MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行 MD5 加密，如果和签名一样，则说明数据确实是真的。

## 11. 什么是数字证书？

对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。所以为了保证发送方的公钥是真的，CA 证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。

## 12. 什么是对称加密和非对称加密？

对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。

非对称加密指使用一对非对称密钥，即：公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性。但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。

## 13. 服务器出现大量close_wait的连接的原因以及解决方法

close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：

- 服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法 
- 服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收

处理方法：

- 停止应用程序
- 修改程序里的bug

## 14. TIME_WAIT出现在哪个阶段，并发量大的情况下TIME_WAIT同时大量存在有什么措施

- 降低TIME_WAIT的等待时间；
- 设置处于TIME_WAIT的端口可重用



## <font color=red> 15. IP协议</font>

### 1. IP地址的分类

A类地址：以0开头，   第一个字节范围：1~126（1.0.0.0 - 126.255.255.255）；

B类地址：以10开头，  第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；

C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；

D类地址：以1110开头，第一个字节范围：224~239（224.0.0.0 - 239.255.255.255）；（作为多播使用）

E类地址：保留

其中A、B、C是基本类，D、E类作为多播和保留使用。

以下是留用的内部私有地址：

A类 10.0.0.0--10.255.255.255

B类 172.16.0.0--172.31.255.255

C类 192.168.0.0--192.168.255.255

IP地址与子网掩码相与得到网络号：

ip       : 192.168.2.110

&

Submask : 255.255.255.0

\----------------------------

网络号   ：192.168.2  .0

注:主机号，全为0的是网络号（例如：192.168.2.0），主机号全为1的为广播地址（192.168.2.255）

### 2. 为什么有了MAC地址还需要IP地址

mac地址就好像个人的身份证号，人的身份证号和人户口所在的城市，出生的日期有关，但是和人所在的位置没有关系，人是会移动的，知道一个人的身份证号，并不能找到它这个人，mac地址类似，它是和设备的生产者，批次，日期之类的关联起来，知道一个设备的mac，并不能在网络中将数据发送给它，除非它和发送方的在同一个网络内。

所以要实现机器之间的通信，我们还需要有ip地址的概念，ip地址表达的是当前机器在网络中的位置，类似于城市名+道路号+门牌号的概念。通过ip层的寻址，我们能知道按何种路径在全世界任意两台Internet上的的机器间传输数据。

mac地址通常是不变的，ip地址是可变的，尤其是移动设备，ip地址会经常变更。

mac地址的设计不携带设备在网络中的位置信息，想要通过mac地址通信，我们得在所有的设备上维护一张很大的表，记录所有mac地址路由在当前位置的的下一跳，这显然是不合理的。



## <font color=red>16. HTTP协议</font>

### 1. HTTP的概念

**HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。**

### 2. HTTP长连接和短链接

- 短链接：客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。
- 长连接： 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。

> 应用场景
>
> - 长连接：常用于p2p通信。
> - 短链接：常用于一点对多通信，c/s通信 

### 3.  HTTP常见状态码

常见的包括：

- 2XX：类状态码表示服务器**成功**处理了客户端的请求

  200 - 请求成功

  **204 No Content**请求成功，但是没有body数据。

  **206 Partial Content**请求成功，但是body数据只是包含部分资源。

- 3xx：类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

  301 - 资源（网页等）被永久转移到其它URL

  **302 Moved Permanently**表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

  **304 Not Modified**不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。

- 4xx：类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

  400 - 请求无效

  403 - 禁止访问

  404 - 请求的资源（网页等）不存在

- 5xx：类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

  500 - 内部服务器错误

  **500 Internal Server Error**与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。

  **501 Not Implemented**表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。

  **502 Bad Gateway**通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。

  **503 Service Unavailable**表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。

### 4. HTTP常见字段

- *Host*：客户端发送请求时，用来指定服务器的域名。
- *Content-Length 字段*：服务器在返回数据时，会有 `Content-Length` 字段，表明本次回应的数据长度。
- *Connection 字段*：`Connection` 字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。
- *Content-Type 字段*：`Content-Type` 字段用于服务器回应时，告诉客户端，本次数据是什么格式。
- *Content-Encoding 字段*：`Content-Encoding` 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式

### 5. GET和POST的区别

1. GET方法不会修改服务器上的资源，它的查询是没有副作用的，而POST有可能会修改服务器上的资源 

   > 举个例子：我们平时访问网站，制定一个URL就会收到服务器响应的数据，但是这个请求本身没有对服务器造成更改，这就是GET方法。如果我们在一个朋友圈下面提交自己的评论，别人再去看这个朋友圈就会看到你的评论，也就相当于对服务器端的内容做出了改变，这就是POST方法。

2. GET把请求附在url上，而POST把参数附在http包的包体中 

3. 一般对get方法所提交的url长度有限制，而对post方法没有限度

4. get产生一个tcp包，post产生两个tcp数据包。post先发header，服务器响应100 continue， 浏览器再发data，服务器响应200（返回数据）。 

5. POST 比GET 更安全，因为参数不会被保存在浏览器历史或web服务器日志中。

### 6. Cookie技术

>  Cookie主要是为了解决HTTP无状态问题而产生的，并且cookie存储在客户端

- 客户端首次向服务器发出请求时，服务器会针对客户端生成一个cookie并添加到响应中，客户端在接收到响应数据后会把cookie保存到本地
- 客户端再次向服务端发出请求的时候，就会再请求报文中添加cookie，这样服务器根据请求中的cookie就可以知道我们的客户端的一个状态，也就弥补了HTTP 无状态的问题。

> cookie和session的区别
>
> - cookie是保存在客户端；session是保存在服务器端

### 7. HTTP和HTTPS的区别

- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。

- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。

- HTTP 的端口号是 80，HTTPS 的端口号是 443。

- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

  

  ![img](https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZfXG1113Sjm0iaOXfoOv0tlUzdWm2toFZmoutgdMlZichgjsFggJOHXg6Z09ckSyeTPpkdywfljh3uw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



### 8. TLS的握手过程

### 9. HTTP各个版本的区别

- HTTP 0.9

  - 只支持`GET`请求方式：由于不支持其他请求方式，因此客户端是没办法向服务端传输太多的信息
  - 没有请求头概念：所以不能在请求中指定版本号，服务端也只具有返回 HTML字符串的能力
  - 不支持长连接，服务端相响应之后，立即关闭TCP连接

- HTTP 1.0

  - 请求方式新增了POST，DELETE，PUT，HEADER等方式

  - 增添了请求头和响应头的概念，在通信中指定了 HTTP 协议版本号，以及其他的一些元信息 (比如: 状态码、权限、缓存、内容编码)

  - 扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输

    >  在这个版本主要的就是对请求和响应的元信息进行了扩展，客户端和服务端有更多的获取当前请求的所有信息，进而更好更快的处理请求相关内容。

- HTTP 1.1

  - 新增connection字段，支持长连接
  - 管道化
  - 支持缓存处理
  - 支持断点传输

- HTTP2.0

  - 二进制分帧：HTTP 1.x 的解析是基于文本，HTTP 2之后将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，提高传输效率
  - 多路复用：在共享TCP连接的基础上同事发送请求和响应
  - 头部压缩
  - 服务器推送：服务器可以额外的向客户端推送资源，而无需客户端明确请求

### 10. HTTP与HTTPS交互的过程




## <font color=red>17. ARP地址解析协议(IP->MAC)</font>

- 1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。
- 2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。
- 3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。
- 4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

## <font color=red>18. DNS域名解析工作原理(URL->IP)</font>

DNS 中的域名都是用**句点**来分隔的，比如 `www.server.com`，这里的句点代表了不同层次之间的**界限**。在域名中，**越靠右**的位置表示其层级**越高**。根域是在最顶层，它的下一层就是 com 顶级域，再下面是 server.com。
所以域名的层级关系类似一个树状结构：

- 根 DNS 服务器
- 顶级域 DNS 服务器（com）
- 权威 DNS 服务器（server.com）

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdCwxNydn5YuT0s7aLuqWCvN6F6eZ2vAU04o8gh1mJ6l7ovc7wsCvTVMvCFHyHqfsRUKtWYnblsCA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



**域名解析的过程**
(1) 在输入域名后, 先查找自己主机对应的域名服务器，域名服务器先查找自己的数据库中的数据。如果存在对应的IP地址就直接返回。
(2) 如果没有， 就向根域名服务器进行查找，如果没有就继续向下面顶级域和权威DNS服务器迭代查询，直到找到这个域名的IP地址并返回。
(3) 在找到URL对应的IP地址以后就可以开始通信了。



![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdCwxNydn5YuT0s7aLuqWCv5bBPibRf9nk4wIb6J3jP62L6NEmPk3HicMUgf8VatcBicynP6BKLeT6GQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



> **DNS缓存的了解**
>
> 目的是为了提高查询效率，减轻服务器的负荷和减少因特网上的 DNS 查询报文数量。
>
> 由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项（例如：每个项目两天）。当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性。



## 19. 在浏览器中输入一个url后执行的全部过程

- 客户端浏览器通过DNS解析到url的的IP地址，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到这个IP地址，然后通过TCP进行封装数据包，输入到网络层。
- 在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，与服务器进行交换，服务器把相应的请求返回给客户端。然后使用IP层的IP地址查找目的端。
- 客户端的网络层，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作。
- 客户端的链路层，包通过链路层发送到路由器，通过ARP协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。

> **在浏览器输入URL地址到显示的过程**
>
> 1. **DNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址**（具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS 缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS 服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询）
> 2. TCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手；
> 3. 发送 HTTP 请求：TCP 连接建立起来后，浏览器向服务器发送 HTTP 请求；
> 4. 服务器处理请求并返回 HTTP 报文：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；
> 5. 浏览器解析渲染页面：浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。
> 6. 连接结束。

## 20. 网络中两台主机通信的过程

> 1. [主机通信过程](https://blog.csdn.net/qq_28657577/article/details/82258141)

**1. 在同一个局域网中**

直接走二层交换机进行通信

**2. 不在同一个局域网中**

需要经过路由器进行通信



## 21. TCP相关开放性问题

### 1. TCP性能瓶颈

当连续接受三个重复的ACK时，发生超时重传，这时候发送端的发送窗口就会阻塞，不能向右继续滑动，也就限制了后面的数据的发送。这就是TCP的性能瓶颈。

> 如何解决？
>
> 使用QUIC技术解决TCP性能瓶颈问题

### 2. TCP连接文件描述符耗尽怎么办

- 客户端最大tcp连接数位65536 - 1 = 65535 port 0 特殊含义
- 服务器的最大tcp连接数， {local ip, local port,remote ip,remote port}
- server最大tcp连接数：server通常固定在某个本地端口上监听，等待client的连接请求。不考虑地址重
  用（unix的SO_REUSEADDR选项）的情况下，即使server端有多个ip，本地监听端口也是独占的，因此
  server端tcp连接4元组中只有remote ip（也就是client ip）和remote port（客户端port）是可变的，
  因此最大tcp连接为客户端ip数×客户端port数，对IPV4，不考虑ip地址分类等因素，最大tcp连接数约为
  2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。
  当系统的文件描述符耗尽的时候，我们要做一些处理：
  - **方式一：**在拿到大于或者等于0的connfd(连接文件描述符)之后，非阻塞的epoll/select一下，看看这个fd是否可写。正常情况下epoll/select会返回writable，表明connfd可用。如果epoll/select返回错误，表示这个fd有问题，应该立刻关闭连接
  - **方式二：**设置一个最大连接数，当连接超过设定值时，直接关闭当前这个fd 

### 3. TCP的7种定时器

> 1. 建立连接定时器(connection-establishment timer)
> 2. 重传定时器(retransmission timer)
> 3. 延迟应答定时器(delayed ACK timer)
> 4. 坚持定时器(persist timer)
> 5. 保活定时器(keepalive timer)
> 6. FIN_WAIT_2定时器(FIN_WAIT_2 timer)
> 7. TIME_WAIT定时器 (TIME_WAIT timer, 也叫2MSL timer) 