# 排序算法



![img](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)



稳定：归并排序、冒泡排序、插入排序

$O(nlogn)$: 堆排序、快速排序、归并排序

# 1. 调度算法

**1.1 进程调度算法**

先来先服务、最短作业优先、时间片轮转调度、优先级调度、多级队列

**1.2 页面置换算法**

最佳置换算法、先进先出置换算法、最近最久未使用算法（LRU）、时钟算法、改进型时钟算法、最少使用算法（LFU）

> **最佳置换算法：**只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。
>
> **先进先出置换算法：**简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。
>
> **最近最久未使用算法LRU：**算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。
>
> **时钟算法clock(也被称为是最近未使用算法NRU)：**页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。
>
> **改进型Clock算法：**在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。
>
> **最少使用算法LFU：**设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。

# 2. 进程和线程通信方式

**2.1 进程**

管道、socket、信号、信号量、共享内存、消息队列

**2.2 线程**

临界区、互斥量、信号量、事件

**2.3 Linux的4种锁机制：**

- 互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会
  进入睡眠，等待锁释放时被唤醒
- 读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻
  只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。
  注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先
  于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于
  写数据的频率的场合。
- 自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡
  眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间
  短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。
- RCU：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修
  改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获
  得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较
  大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少
  量写操作的情况下效率非常高。 

# 3. 死锁

**死锁的原因：**

- 资源竞争
- 进程推进的顺序非法

**死锁产生的必要条件**：

- 不可剥条件:进程对于已经申请到的资源在使用完成之前不可以被剥夺
- 互斥条件:进程对所分配的资源进行排他性的使用
- 请求和保持条件:进程被阻塞的时候并不释放锁申请到的资源
- 环路等待条件:发生死锁的时候存在的一个 进程-资源 环形等待链



**死锁处理：**

1. 预防死锁：破坏产生死锁的4个必要条件中的一个或者多个；实现起来比较简单，但是如果限制过于严格会降低系统资源利用率以及吞吐量

   - **破坏互斥**

   > 通过与锁完全不同的同步方式CAS，CAS提供原子性支持，实现各种无锁的数据结构，不仅可以避免互斥锁带来的开销也可避免死锁问题。

   - **破坏不可剥夺**

   > 如果一个线程已经获取到了一些锁，那么在这个线程释放锁之前这些锁是不会被强制剥夺的。但是为了防止死锁的发生，我们可以选择让线程在获取后续的锁失败时主动放弃自己已经持有的锁并在之后重试整个任务，这样其他等待这些锁的线程就可以继续执行了。

   - **破坏环路等待**

   > 在实践的过程中，采用破坏环路等待的方式非常常见，这种技术叫做"锁排序"。很好理解，我们假设现在有个数组A，采用单向访问的方式(从前往后)，依次访问并加锁，这样一来，线程只会向前单向等待锁释放，自然也就无法形成一个环路了。

2. 避免死锁：在资源的动态分配中，防止系统进入不安全状态(可能产生死锁的状态)-如银行家算法

   - **银行家算法**

     当进程首次申请资源时，要测试该进程对资源的**最大需求量**，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。

     当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源。若没超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若满足则按当前的申请量分配资源，否则也要推迟分配。

   - **安全序列**

     是指系统能按某种进程推进顺序（P1, P2, P3, …, Pn），为每个进程 Pi 分配其所需要的资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺序地完成。这种推进顺序就叫安全序列【银行家算法的核心就是找到一个安全序列】。

   - **系统安全状态**

     如果系统能找到一个安全序列，就称系统处于安全状态，否则，就称系统处于不安全状态。

3. 检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大

4. 解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。

   - 资源剥夺：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程（但应该防止被挂起的进程长时间得不到资源）；
   - 撤销进程：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源（撤销的原则可以按进程优先级和撤销进程代价的高低进行）；
   - 进程回退：让一个或多个进程回退到足以避免死锁的地步。进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。

# 4. 线程、进程上下文切换

> <font color=blue>进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</font>

**进程切换分两步：**

**1. 切换页目录以使用新的地址空间**

**2. 切换内核栈和硬件上下文**

**对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。**



**两者切换的性能消耗对比**：

1. **线程上下文切换和进程上下文切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的**。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。

2. **另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制**。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲 (TLB) 或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。

# 5. 智能指针

> 1. [C++11中智能指针的原理、使用、实现](https://www.cnblogs.com/wxquare/p/4759020.html)

智能指针和普通指针类似，只是不需要手动释放指针，而是通过智能指针自己管理内存的释放，**智能指针可以很好的避免内存泄漏的问题**。 智能指针包括：**auto_ptr（在C++11中已经废弃）、共享指针(shared_ptr)、弱指针（weak_ptr）和独占指针（unique_ptr）**

- **unique_ptr(独占指针)**

  ![转移 unique_ptr 的所有权](https://i-msdn.sec.s-msft.com/dynimg/IC786112.jpeg)

  - Unique_ptr是一个独占的智能指针，他不允许其他的智能指针共享其内部的指针，不允许通过赋值将一个unique_ptr赋值给另外一个 unique_ptr。
  - unique_ptr不允许复制，但可以通过函数返回给其他的unique_ptr，还可以通过move来转移到其他的unique_ptr，这样它本身就不再拥有原来指针的所有权了。
  - 如果希望只有一个智能指针管理资源或管理数组就用unique_ptr，如果希望多个智能指针管理同一个资源就用shared_ptr。

  ```C++
  #include<bits/stdc++.h>
  using namespace std;
  
  // 使用举例
  void useExample(){
      //创建一个指向int的空指针
      std::unique_ptr<int> fPtr1;
      std::unique_ptr<int> fPtr2(new int(4));
      auto fPtr3 = std::make_unique<int>();
      
      //fPtr2释放指向对象的所有权，并且被置为nullptr
      std::cout << "fPtr2 release before:" << fPtr2.get() << std::endl;
      int *pF = fPtr2.release();
      std::cout << "fPtr2 release after:" << fPtr2.get() << " and pF value:" << *pF << std::endl;
      
      //所有权转移，转移后fPtr3变为空指针
      std::cout << "move before fPtr1 address:" << fPtr1.get() << " fPtr3 address:" << fPtr3.get() << std::endl;
      fPtr1 = std::move(fPtr3);
      std::cout << "move after  fPtr1 address:" << fPtr1.get() << " fPtr3 address:" << fPtr3.get() << std::endl;
  
      std::cout << "move before fPtr1 address:" << fPtr1.get() << std::endl;
      fPtr1.reset();
      std::cout << "move after  fPtr1 address:" << fPtr1.get() << std::endl;
      
  }
  
  unique_ptr<int> clone(int p)
  {
      unique_ptr<int> pInt(new int(p));
      return pInt;    // 返回unique_ptr
  }
  
  int main()
  {
      // 1. 创建一个unique_ptr实例
      unique_ptr<int> pInt(new int(5));
      cout << "pInt1: " << *pInt << endl;
  
      // 2. unique_ptr不可以复制和拷贝
      // unique_ptr<int> pInt2(pInt);    // 报错
      // unique_ptr<int> pInt3 = pInt;   // 报错
  
      // 3. unique_ptr可以进行移动
      unique_ptr<int> pInt2 = move(pInt);    // 转移所有权
      // cout << *pInt << endl; // 出错，pInt为空
      cout << "pInt2: " << *pInt2 << endl;
      unique_ptr<int> pInt3(move(pInt2));
      cout << "pInt3: " << *pInt3 << endl;
  
      // 4. 可以作为返回对象返回
      unique_ptr<int> res = clone(6);
      cout << "result of function: " << *res << endl;
  
      useExample();
      return 0;
  }
  ```

  > 注意：
  >
  > - release和reset的区别：前者会释放控制权，返回裸指针，你还可以继续使用。而后者直接释放了指向对象。

- **shared_ptr(共享指针)**

  > 1. [shared_ptr的用法](https://www.cnblogs.com/jiayayao/p/6128877.html)

  **shared_ptr多个指针指向相同的对象**。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。

  > 注意事项：
  >
  > 1. 不要用一个原始指针初始化多个shared_ptr。 
  > 2. 不要在函数实参中创建shared_ptr，在调用函数之前先定义以及初始化它。 
  > 3. 不要将this指针作为shared_ptr返回出来。 
  > 4. 要避免循环引用。

  ```C++
  # include<bits/stdc++.h>
  using namespace std;
  
  class Person{
  public:
      Person(int v) { // 构造函数
          value = v;
          cout << "Cons" <<value<< endl;
      }
      ~Person() { // 析构函数
          cout << "Des" <<value<< endl;
      }
      int value;
  };
  
  
  int main(){
      shared_ptr<Person> p1(new Person(1));// Person(1)的引用计数为1
      shared_ptr<Person> p2 = make_shared<Person>(2);
      // std::shared_ptr<int> p4 = new int(1);// error
  
      p1.reset(new Person(3));// 先生成新对象，然后引用计数减1，引用计数为0，故析构Person(1)
                              // 最后将新对象的指针交给智能指针
      shared_ptr<Person> p3 = p1;//现在p1和p3同时指向Person(3)，Person(3)的引用计数为2
      p1.reset();//Person(3)的引用计数为1
      p3.reset();//Person(3)的引用计数为0，析构Person(3)
      return 0;
  }
  ```

  

- **weak_ptr（弱指针**）

  weak_ptr是弱智能指针对象，它不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的智能指针。将一个weak_ptr绑定到一个shared_ptr对象，不会改变shared_ptr的引用计数。一旦最后一个所指向对象的shared_ptr被销毁，所指向的对象就会被释放，即使此时有weak_ptr指向该对象，所指向的对象依然被释放。

  weak_ptr是用来监视shared_ptr的，不会使引用计数加一，它不管理shared_ptr内部的指针，主要是为了监视shared_ptr的生命周期。 weak_ptr没有重载运算符*和->，因为它不共享指针，不能操作资源，主要是为了通过shared_ptr获得资源的监测权，它的构造不会增加引用计数，它的析构不会减少引用计数，纯粹只是作为一个旁观者来监视shared_ptr中关联的资源是否存在。 weak_ptr还可以用来返回this指针和解决循环引用的问题。

> 什么是循环引用
>
> 内存的正常回收：
>
> ![img](https://upload-images.jianshu.io/upload_images/2118879-1f06c66f210fb3e3.png?imageMogr2/auto-orient/strip|imageView2/2/w/472/format/webp)

> 循环引用导致的内存泄漏：
>
> ![img](https://upload-images.jianshu.io/upload_images/2118879-09fed596c7d95b42.png?imageMogr2/auto-orient/strip|imageView2/2/w/443/format/webp)
>
> 



# 6. 有了进程为什么还需要线程

**线程产生的原因：**

进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：

- 进程在同一时间只能干一件事
- 进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行。

因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。

# 7. 线程安全

**7.1 线程安全是什么**

如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和[单线程](https://baike.baidu.com/item/单线程)运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。或者说:一个类或者程序所提供的接口对于线程来说是[原子操作](https://baike.baidu.com/item/原子操作)或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。

线程安全问题都是由[全局变量](https://baike.baidu.com/item/全局变量)及[静态变量](https://baike.baidu.com/item/静态变量)引起的。

若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑[线程同步](https://baike.baidu.com/item/线程同步)，否则的话就可能影响线程安全。



**7.2 如何保证线程安全**
 <font color=blue>一般说来，确保线程安全的方法有这几个：竞争与原子操作、同步与锁、可重入、过度优化。</font>

- **竞争与原子操作** 
  多个线程同时访问和修改一个数据，可能造成很严重的后果。出现严重后果的原因是很多操作作系统编译为汇编代码之后不止一条指令，因此在执行的时候可能执行了一半就被调度系统打断了而去执行别的代码了。一般将单指令的操作称为原子的(Atomic)，因为不管怎样，单条指令的执行是不会被打断的。因此，为了避免出现多线程操作数据的出现异常，Linux系统提供了一些常用操作的原子指令，确保了线程的安全。但是，它们只适用于比较简单的场合，在复杂的情况下就要选用其他的方法了。
- **同步与锁** 
  为了避免多个线程同时读写一个数据而产生不可预料的后果，开发人员要将各个线程对同一个数据的访问同步，也就是说，在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。同步的最常用的方法是使用锁(Lock)，它是一种非强制机制，每个线程在访问数据或资源之前首先试图获取锁，并在访问结束之后释放锁；在锁已经被占用的时候试图获取锁时，线程会等待，直到锁重新可用。二元信号量是最简单的一种锁，它只有两种状态：占用与非占用，它适合只能被唯一一个线程独占访问的资源。对于允许多个线程并发访问的资源，要使用多元信号量(简称信号量)。
- 可重入 
  一个函数被重入，表示这个函数没有执行完成，但由于外部因素或内部因素，又一次进入该函数执行。一个函数称为可重入的，表明该函数被重入之后不会产生任何不良后果。可重入是并发安全的强力保障，一个可重入的函数可以在多线程环境下放心使用。
- 过度优化 
  在很多情况下，即使我们合理地使用了锁，也不一定能够保证线程安全，因此，我们可能对代码进行过度的优化以确保线程安全。 我们可以使用volatile关键字试图阻止过度优化，它可以做两件事：第一，阻止编译器为了提高速度将一个变量缓存到寄存器而不写回；第二，阻止编译器调整操作volatile变量的指令顺序。在另一种情况下，CPU的乱序执行让多线程安全保障的努力变得很困难，通常的解决办法是调用CPU提供的一条常被称作barrier的指令，它会阻止CPU将该指令之前的指令交换到barrier之后，反之亦然。  