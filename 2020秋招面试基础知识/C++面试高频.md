## 内存管理

　　在C++中，内存分成5个区，他们分别是**堆、栈、自由存储区、全局/静态存储区和常量存储区**。

　　**栈**，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

　　**自由存储区**，（自由存储区也是堆上分出的一块内存，只不过在C++中称为自由存储区）就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

　　**堆**，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。

　　**全局/静态存储区**，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。

　　**常量存储区**，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

## 1. 指针和引用的区别

- 定义一个指针时可以先声明或者初始化为NULL； 但是引用在声明时就必须初始化;
- 指针的大小一般为4个字节，引用的大小取决于被引用对象的大小
- 指针可以有多级，但是引用不可以
- 传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改
- 指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作

## 2. static和const

**static**（在全局/静态存储区申请空间）

- **静态变量**：被static修饰的变量就是静态变量，它会在程序运行期间一直存在，会被放在静态存储区。局部静态变量的作用域在函数体中，全局静态变量的作用域在整个文件。

- **静态函数**：被static修饰的函数就是静态函数，静态函数只能在本文件中使用，不能被其他文件调用，也不会和其他文件中的同名函数冲突。

- **类中的静态成员**：而在类中，被static修饰的成员变量是类静态成员，这个静态成员属于类而不是属于谋改革对象。被static修饰的成员函数也属于静态成员，也是属于类而不是属于某个对象。(访问这个静态函数不需要引用对象名，而是通过引用类名来访问)

**const**

- 由const修饰的变量不可修改；
- 由const修饰的函数，在其内部不可对变量进行修改。
- 定义的const的变量是可以被其他源文件访问的，但是要用extern

**const和static在类中使用的注意事项（定义、初始化和使用)**

- 非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern。
- 由于声明为static的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量**由对象共享。**对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，静态变量不能使用构造函数初始化。

**C++中的const类成员函数（用法和意义）**

- const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；
- 非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；

## 3. new/delete 和malloc/free的区别

> new是如何实现的：在new一个对象的时候，首先会调用malloc为对象分配内存空间，然后调用对象的构造函数。delete会调用对象的析构函数，然后调用free回收内存。

- new/delete是关键字，而malloc/free是库函数；
- new在自由存储区分配内存。而malloc是在堆上分配内存；
- new/delete会调用构造/析构函数，但是malloc/free不会
- new在使用时不用声明申请内存的大小，但是malloc必须指定申请的内存大小
- 内存分配失败时，new抛出异常，但是malloc返回NULL；

> **delete和delete[]的区别：**
>
> - delete只会调用一次析构函数，但是delete[]会调用每个成员的析构函数
> - 用new分配的内存用delete释放，用new[]分配的内存用delete[]释放

> **为什么要求new和delete**
>
> 因为在C++中是存在对象的，当对非基本数据类型“对象”使用的时候，对象创建和销毁需要使用构造函数和析构函数，而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free。

## 4. 深拷贝与浅拷贝

- 浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，
- 深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针

## 5. 栈和堆的区别

**堆栈空间分配** 

栈（操作系统）：由操作系统自动分配释放 ，存放函数的[参数值](http://baike.baidu.com/view/1703315.htm)，[局部变量](http://baike.baidu.com/view/552847.htm)的值等。其操作方式类似于数据结构中的栈。

堆（操作系统）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。

**堆栈缓存方式** 

栈使用的是[一级缓存](http://baike.baidu.com/view/16882.htm)， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。

堆则是存放在[二级缓存](http://baike.baidu.com/view/27650.htm)中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

**堆栈数据结构区别** 

栈（数据结构）：一种先进后出的数据结构。

堆（数据结构）：堆可以被看成是一棵树，如：堆排序。

## 6. struct和class的区别

在C++中，可以用struct和class定义类，都可以继承。

**区别在于：**

- struct的默认继承权限和默认访问权限是public，
- class的默认继承权限和默认访问权限是private。另外，class还可以定义模板类形参，比如template <class T, int i>。

## 7. define 和const的区别

**1.编译器处理方式**

define – 在预处理阶段进行替换 ； 
const – 在编译时确定其值；

**2.类型检查**

define – 无类型，不进行类型安全检查，可能会产生意想不到的错误 
const – 有数据类型，编译时会进行类型检查

**3.内存空间**

define – 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大。 const – 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝

**4.其他**

const可以定义函数，但是define不可以。



> define和typedef的区别
>
> - define是预处理命令，在预处理是执行简单的替换，不做正确性的检查
> - typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名

## 8. C++内存管理

- **栈区**：主要存储函数的参数和局部变量。栈区由系统进行内存管理，在函数完成执行时，系统会自行释放栈区的内存，而不需要用户参与管理。
- **堆区：**由用户手动申请，手动释放。如：malloc/free开辟内存的空间，从低地址向高地址增长。   
- **自由存储区：**就是由new/delete开辟内存空间。   

> - ​       通常认为C++中有两个动态内存区域。通过new/delete方式进行内存资源的分配和释放的称为自由存储区（free store），而通过malloc/free方式进行内存资源的分配和释放的称为堆区（heap）。      
> - ​       本质上来说很多编译器中的new操作符是通过malloc进行内存申请的**，因此**可以将自由存储区理解为堆区的一个具体实现，虽然二者不完全相同，但很多时候可以混为一谈。

- ​    **全局/静态存储区**：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。   

  ​    注意：   

  > ​     在C语言中，初始化的全局变量和静态变量放在一块内存区域中，而未初始化的全局变量和静态变量放在与之相邻的另一块内存区域中。而在C++中则没有在静态区中将初始化的和未初始化的变量进行分开存储，因为C++会对未初始化的全局变量和静态变量进行默认初始化（一般默认初始化为0）。该区域存储的数据会在程序结束后由系统来释放。    

- ​    **常量存储区：**这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

## 9. 重载和重写、隐藏(重定义)的区别

**基本概念**

- 重载(函数名相同，但是参数列表不同)：是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。
- 隐藏(重定义)：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。
- 重写(覆盖，函数相同，参数列表也相同，方法体不相同)：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。

**重载和重写的区别：**

（1）范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中。
（2）参数区别：重写的函数参数列表是相同的，重载和被重载的函数参数列表一定不同。
（3）virtual的区别：重写的基类必须要有virtual修饰，重载函数和被重载函数可以被virtual修饰，也可以没有。

**隐藏和重写，重载的区别：**

（1）与重载范围不同：隐藏函数和被隐藏函数在不同类中。

（2）参数的区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定同；当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。 

## 10. 封装、继承、多态

面向对象的三个基本特征是：封装、继承、多态。封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用。

**什么是封装？**

封装是把过程和数据包围起来，对数据的访问只能通过已定义的接口。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。在面向对象编程上可理解为：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

**什么是继承？**

- 继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。其继承的过程，就是从一般到特殊的过程。
- 通过继承创建的新类称为“子类”或“派生类”。被继承的类称为“基类”、“父类”或“超类”。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。

**继承类型**

当一个类派生自基类，该基类可以被继承为 **public、protected** 或 **private** 几种类型

- **公有继承（public）：**当一个类派生自**公有**基类时，基类的**公有**成员也是派生类的**公有**成员，基类的**保护**成员也是派生类的**保护**成员，基类的**私有**成员不能直接被派生类访问，但是可以通过调用基类的**公有**和**保护**成员来访问。
- **保护继承（protected）：** 当一个类派生自**保护**基类时，基类的**公有**和**保护**成员将成为派生类的**保护**成员。
- **私有继承（private）：**当一个类派生自**私有**基类时，基类的**公有**和**保护**成员将成为派生类的**私有**成员。

**继承的实现方式？**

继承概念的实现方式有三类：实现继承、接口继承和可视继承。

- 实现继承是指使用基类的属性和方法而无需额外编码的能力；
- 接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；
- 可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。

## 11. 多态

**什么是多态？**

同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。多态一般跟随继承的概念，利用基类初始化一个指针指向子类，当调用不同子类的相同函数时可以得到不同的结果。

多态又分为**静态多态和动态多态**，静态多态是利用重载实现，动态多态是利用虚函数机制（**虚函数机制是利用虚函数表来实现**）实现。



> C++ 多态包括编译时多态和运行时多态，
>
> - 编译时多态体现在函数重载和模板上；
> - 运行时多态体现在虚函数上。



## 12. 虚函数相关

**什么是虚函数**

基于基类的指针操作他的多态类对象时，会根据不同的对象调用相应对象的函数，这个函数就是虚函数。

**虚函数实现机制（虚函数表和虚指针）**

- 虚函数的实现是利用**虚函数表和虚函数指针**来实现

- 虚函数都会有一个对应的虚函数表，该虚函数表存放的是每一个对象的虚函数入口地址。对于一个派生类来说，他会继承基类的虚函数表同时增加自己的虚函数入口地址，如果派生类重写了基类的虚函数，那么被继承的虚函数入口地址将被派生类的虚函数入口地址替代。

**什么是虚函数表**

- 虚函数表是每个类中存放虚函数地址的指针数组，类的实例在调用函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚指针会指向子类实现的函数地址，否则指向父类的函数地址。
- 一个类的所有实例对象都**共享同一张虚函数表**。**但是每一个对象都有一个自己的虚指针**  

**纯虚函数**

- 形如：
  virtual 返回类型 函数名 (形参表) = 0;

```
class Animal {
public:
	virtual void eat (void) = 0;
	virtual void run (void) = 0;
	virtual void cry (void) = 0;
};
```

的虚函数，称为纯虚函数或抽象方法，表达一种抽象化的行为概念

- 如果一类含有至少一个纯虚函数，那么该类就是一个抽象类，他不能被实例化，只有实现了这个纯虚函数的子类才能生成对象
- 除了构造函数和析构函数以外全部成员函数都是纯虚函数的抽象类叫做纯抽象类，亦称接口类 

## 13. C++所有的构造函数

**默认构造函数、一般构造函数和拷贝构造函数**

- 默认构造函数（无参数）：如果创建一个类你没有写任何构造函数,则系统会自动生成默认的构造函数，或者写了一个不带任何形参的构造函数
- 一般构造函数：一般构造函数可以有各种参数形式,一个类可以有多个一般构造函数，前提是参数的个数或者类型不同（基于c++的重载函数原理）
- 拷贝构造函数参数为类对象本身的引用，用于根据一个已存在的对象复制出一个新的该类的对象，一般在函数中会将已存在对象的数据成员的值**复制**一份到新创建的对象中。参数（对象的引用）是不可变的（const类型）。**此函数经常用在函数调用时用户定义类型的值传递及返回**。

> **什么情况下会调用拷贝构造函数**
>
> - 对象以值传递的方式传入函数参数。如 `void func(Dog dog){};`
> - 对象以值传递的方式从函数返回。如 `Dog func(){ Dog d; return d;}`
> - 对象需要通过另一个对象进行初始化



## 14. 析构函数一般写成虚函数的原因

> 只有一个类是基类要构成多态时才令其析构函数为虚函数，这样可以节省内存空间。否则就是浪费。

如果一个基类的析构函数不是虚构函数，在继承类对象经由一个基类指针被删除是可能无法释放其占用的空间，进而可能造成内存泄漏，破坏数据结构。



## 15. 构造函数为什么一般不定义为虚函数

- 因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等
- 虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了



## 16. [静态绑定和动态绑定](https://www.cnblogs.com/conanpeng/p/12799419.html)

- 静态绑定在编译期完成，指针指的是静态对象。
- 动态绑定在运行期完成，虚函数中的指针指向对象。（基类指针指向派生类对象）

在C++中动态绑定是通过虚函数实现的。基类指针调用虚函数时发生动态绑定。基类指针既可以指向基类对象，又可以指向派生类对象，这是动态绑定的关键。指针调用的虚函数在运行时确定，被调用的虚函数是由指针所指对象的实际类型（基类或派生类）定义的。

## 17. 引用是否能实现动态绑定，为什么引用可以实现 

 **可以**。因为引用（或指针）既可以指向基类对象也可以指向派生类对象，这一事实是动态绑定的关键。用引用（或指针）调用的虚函数在运行时确定，被调用的函数是引用（或指针）所指的对象的实际类型所定义的。 

## 18. 什么情况下会调用拷贝函数

- 用类的一个对象去初始化另一个对象时
- 当函数的形参是类的对象时（也就是值传递时），如果是引用传递则不会调用
- 当函数的返回值是类的对象（返回值为引用不会调用拷贝构造函数）

## 19. 内存泄漏，如何检测和避免

**1. 什么是内存泄漏？**

内存泄漏(memory leak)是指由于疏忽或错误造成了**程序未能释放掉不再使用的内存的情况**。内存泄漏并非指内存在物理上的消失，而是[应用程序](http://baike.baidu.com/view/330120.htm)分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。

**2. 内存泄漏的后果？** 

最难捉摸也最难检测到的错误之一是内存泄漏，即未能正确释放以前分配的内存的 bug。 只发生一次的小的内存泄漏可能不会被注意，但泄漏大量内存的程序或泄漏日益增多的程序可能会表现出各种征兆：从性能不良（并且逐渐降低）到内存完全用尽。 更糟的是，泄漏的程序可能会用掉太多内存，以致另一个程序失败，而使用户无从查找问题的真正根源。 此外，即使无害的内存泄漏也可能是其他问题的征兆。

**3. 内存泄漏的分类：**

1. 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.
2. 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。
3. 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。

**4. 解决内存泄漏最有效的办法就是使用智能指针（Smart Pointer）。**

**5. 如何检测内存泄漏**

- 在Linux系统下可以采用检测工具valgrind。
- 可以在写代码的时候采用内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。

**6. 什么时候发生段错误**（**段错误通常发生在访问非法内存地址的时候**）

- 使用野指针
- 非法修改const修饰的常量的时候

## 20. 模板的用法与适用场景 

 代码可重用，泛型编程，在不知道参数类型下，函数模板和类模板 

## 21. 成员初始化列表的概念，为什么快

> **初始化列表为什么快？**
>
> 因为<font color=blue>使用成员初始化列表进行初始化的话，**会直接使用传入参数的拷贝构造函数进行初始化，省去了一次调用默认构造函数的过程。所以使用成员初始化列表效率会高一些**。</font>

**何谓初始化列表**

与其他函数不同，构造函数除了有名字，参数列表和函数体之外，还可以有初始化列表，初始化列表以冒号开头，后跟一系列以逗号分隔的初始化字段。在C++中，struct和class的唯一区别是默认的访问性不同，而这里我们不考虑访问性的问题，所以下面的代码都以struct来演示。

```
struct foo{
    string name ;
    int id ;
    foo(string s, int i):name(s), id(i){} ; // 初始化列表
};
```

**构造函数的两个执行阶段**

构造函数的执行可以分成两个阶段，初始化阶段和计算阶段，初始化阶段先于计算阶段。

**初始化阶段**

所有类类型（class type）的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中。

**计算阶段**

一般用于执行构造函数体内的赋值操作，下面的代码定义两个结构体，其中Test1有构造函数，拷贝构造函数及赋值运算符，为的是方便查看结果。Test2是个测试类，它以Test1的对象为成员，我们看一下Test2的构造函数是怎么样执行的。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```c++
struct Test1
{
    Test1() // 无参构造函数
    { 
        cout << "Construct Test1" << endl ;
    }

    Test1(const Test1& t1) // 拷贝构造函数
    {
        cout << "Copy constructor for Test1" << endl ;
        this->a = t1.a ;
    }

    Test1& operator = (const Test1& t1) // 赋值运算符
    {
        cout << "assignment for Test1" << endl ;
        this->a = t1.a ;
        return *this;
    }

    int a ;
};

struct Test2
{
    Test1 test1 ;
    Test2(Test1 &t1)
    {
        test1 = t1 ;
    }
};
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

调用代码

```c++
Test1 t1 ;
Test2 t2(t1) ;
```

输出

![img](https://pic002.cnblogs.com/images/2012/64257/2012091523283349.png)

解释一下，第一行输出对应调用代码中第一行，构造一个Test1对象。第二行输出对应Test2构造函数中的代码，用默认的构造函数初始化对象test1，这就是所谓的初始化阶段。第三行输出对应Test1的赋值运算符，对test1执行赋值操作，这就是所谓的计算阶段。

**为什么使用初始化列表**

初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。使用初始化列表主要是基于性能问题，对于内置类型，如int, float等，使用初始化类表和在构造函数体内初始化差别不是很大，但是对于类类型来说，最好使用初始化列表，为什么呢？<font color=blue>**由上面的测试可知，使用初始化列表少了一次调用默认构造函数的过程，这对于数据密集型的类来说，是非常高效的**</font>。同样看上面的例子，我们使用初始化列表来实现Test2的构造函数

```c++
struct Test2{
    Test1 test1 ;
    Test2(Test1 &t1):test1(t1){}
}
```

使用同样的调用代码，输出结果如下。

![img](https://pic002.cnblogs.com/images/2012/64257/2012091523291178.png)

第一行输出对应 调用代码的第一行。第二行输出对应Test2的初始化列表，直接调用拷贝构造函数初始化test1，省去了调用默认构造函数的过程。所以一个好的原则是，能使用初始化列表的时候尽量使用初始化列表。

<font color=red>**哪些东西必须放在初始化列表中**</font>

除了性能问题之外，有些时场合初始化列表是不可或缺的，以下几种情况时必须使用初始化列表

- **常量成员**，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
- **引用类型**，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
- **没有默认构造函数的类类型**，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。

对于没有默认构造函数的类，我们看一个例子。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```c++
struct Test1
{
    Test1(int a):i(a){}
    int i ;
};

struct Test2
{
    Test1 test1 ;
    Test2(Test1 &t1)
    {
        test1 = t1 ;
    }
};
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

以上代码无法通过编译，因为Test2类中Test1 test1;需要调用默认的构造函数，但是Test1类没有无参的构造函数，但是由于Test1没有默认的构造函数，故而编译错误。正确的代码如下，使用初始化列表代替赋值操作。

```c++
struct Test2
{
    Test1 test1 ;
    Test2(Test1 &t1):test1(t1){}
}
```

**成员变量的初始化顺序**

成员是按照他们在类中出现的顺序进行初始化的，而不是按照他们在初始化列表出现的顺序初始化的，看代码。

```c++
struct foo
{
    int i ;
    int j ;
    foo(int x):i(x), j(i){}; // ok, 先初始化i，后初始化j
};
```

再看下面的代码

```c++
struct foo
{
    int i ;
    int j ;
    foo(int x):j(x), i(j){} // i值未定义
};

```

这里i的值是未定义的，虽然j在初始化列表里面出现在i前面，但是i先于j定义，所以先初始化i，但i由j初始化，此时j尚未初始化，所以导致i的值未定义。所以，一个好的习惯是，按照成员定义的顺序进行初始化。

## 22. vector和list的区别

- 底层结构

  **vector**的底层结构是动态顺序表，在内存中是一段连续的空间。
  **list**的底层结构是带头节点的双向循环[链表](https://blog.csdn.net/Shuffle_Ts/article/details/95055467)，在内存中不是一段连续的空间。

- 随机访问

  **vector**支持随机访问，可以利用下标精准定位到一个元素上，访问某个元素的时间复杂度是O(1)。
  **list**不支持随机访问，要想访问list中的某个元素只能是从前向后或从后向前依次遍历，时间复杂度是O(N)。

- 插入和删除

  **vector**任意位置插入和删除的效率低，因为它每插入一个元素（尾插除外），都需要搬移数据，时间复杂度是O(N)，而且插入还有可能要增容，这样一来还要开辟新空间，拷贝元素，是旧空间，效率会更低。
  **list**任意位置插入和删除的效率高，他不需要搬移元素，只需要改变插入或删除位置的前后两个节点的指向即可，时间复杂度为O(1)。

- 空间利用率

  **vector**底层为连续空间，不容易造成内存碎片，空间利用率高，缓存利用率高。
  **list**的底层节点动态开辟空间，小节点容易造成内存碎片，空间利用率低，缓存利用率低。

- 迭代器

  **vector**的迭代器是原生态指针。
  **list**对原生态指针（节点的指针）进行了封装。

- 迭代器失效

  **vector**在插入元素时的时候，要重新给所有的迭代器赋值，因为插入元素有可能导致扩容，只是原来的迭代器失效，删除元素时当前迭代器同样需要重新赋值，否则会失效。
  **list**在插入元素的时候不会导致迭代器实现，删除元素的时候指挥导致当前迭代器失效，其他的迭代器不会受到影响。

- 使用场景

  **vector**适合需要高效率存储，需要随机访问，并且不管行插入和删除效率的场景。
  **list**适合有大量的插入和删除操作，并且不关心随机访问的场景

## 23. C++的STL介绍

- STL中map和unordered_map的应用场景区别

  -  unordered_map是使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现==操作符。

  -  map底层是采用红黑树实现的，插入删除查询时间复杂度都是O(log(n))，它的内部是有序的，因此需要实现比较操作符(<)。

- STL包括容器、迭代器、算法（查找、排序）、函数对象、适配器、空间配置器

- 各种容器：

  - vector：可变大小数组，支持快速随机访问，在尾部之外的位置插入或者删除元素可能很慢

    > 对vector的任何操作一旦引起了空间的重新配置，指向原vector的所有迭代器就会都失效。

    size() : 当前有多少元素; 

    capacity() : 可容纳多少元素；

    vector元素不能是引用，因为vector元素需要有实际地址

  - deque：双端队列，支持快速随机访问，在头尾插入删除速度很快

    底层是双向开口的连续线性空间

  - list：双向链表，只支持双向顺序访问，在任何位置插入删除速度很快

    底层是双向链表，push_back(), pop_back(), push_front(), pop_front()

  - array：固定大小数组，不能添加删除元素

  - string：专门存储字符，与vector类似

  - priority_queue：优先队列，*底层用堆实现的*

    ```c++
    priority_queue<int, vector<int>, greater<int>> pq; //最小堆
    priority_queue<int, vector<int>, less<int>> pq; //最大堆
    pq.top();//优先级最高（堆顶）
    pq.pop();//删除最高
    ```

- map，set，multiset，multimap

  底层都是红黑树

  - map中mp.count(key) > 0和mp.find(key) != mp.end()都可以表示key存在
    - set,multiset会自动排序，set不允许元素重复，multiset可以重复
    - map, multimap将key, value组成的pair作为元素，根据key排序

- unordered_map, unordered_set

  - 底层是防冗余的哈希表（除留余数法）
    - 常数级别查找，但是耗内存

## 24. STL源码中的hash表的实现

- [参考链接1](https://light-city.club/sc/src_analysis/stl/hashtable/)
- [参考链接2](https://blog.csdn.net/ddkxddkx/article/details/6555754)

## 25. STL中unordered_map和map的区别

**内部实现机理不同**

- **map：** 内部实现了一个**红黑树**（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。
- **unordered_map**: 内部实现了一个**哈希表**（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用），unordered_map占用内存比较多，查询速度比较快，是常数时间复杂度 。另外，其元素的排列顺序是无序的。

**优缺点以及适用条件**

**map：**

```
优点：
    有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作
    红黑树，内部实现一个红黑书使得map的很多操作在log(n)的时间复杂度下就可以实现，因此效率非常的高

缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间

适用处：对于那些有顺序要求的问题，用map会更高效一些
```

**unordered_map：**

```
优点： 因为内部实现了哈希表，因此其查找速度非常的快
缺点： 哈希表的建立比较耗费时间
适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map
```

**总结：**

```
内存占有率的问题就转化成红黑树 VS hash表 , 还是unorder_map占用的内存要高。
但是unordered_map执行效率要比map高很多
对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的
```

## 26. STL中vector的实现

STL中的vector是封装了动态数组的顺序容器。不过与动态数组不同的是，vector可以根据需要自动扩大容器的大小。具体策略是每次容量不够用时重新申请一块大小为原来容量两倍的内存，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针。  

在原来空间不够存储新值时，**每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的。**

## 27. vector使用的注意点及其原因

如果需要频繁插入，最好先指定vector的大小，因为vector在容器大小不够用的时候会重新申请一块大小为原容器两倍的空间，并将原容器的元素拷贝到新容器中，并释放原空间，这个过程是十分耗时和耗内存的。**频繁调用push_back()会使得程序花费很多时间在vector扩容上，会变得很慢。这种情况可以考虑使用list。**  

## **28. 什么是Reactor模式**

> 1.[Reactor模式简介](https://lotabout.me/2018/reactor-pattern/)

reactor模型要求主线程只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程，除此之外，主线程不做任何其他实质性的工作，读写数据、接受新的连接以及处理客户请求均在工作线程中完成

## 29. 右值引用

> 1.[从4行代码看右值引用](https://www.cnblogs.com/qicosmos/p/4283455.html)

**1. 什么是右值引用**

C++中所有的值都必然属于左值或者右值。**左值**是指表达式结束后依旧存在的持久化对象，**右值**是指表达式结束时就不再存在的临时对象。所有具名变量或者对象都是左值，而右值不具名。有一个可以**区分左值和右值**的便捷方法：看能不能对表达式取地址，如果能，则为左值，否则为右值。 

```C++
A && a = getTemp(); //getTemp()的返回值是右值（临时变量）
```

常见右值：**字面常量，匿名对象，以及函数的返回值**。 另外，也可以通过 std::move 显式地将一个左值转换为右值。

> ```c++
> int a; //变量
> const int b = 10; //b为常量，10为字面量
> string str = “hello world！”; // str 为变量，hello world！为字面量
> int a=123 // 这里的a为左值，123为右值 123在使用之后就不再存在了，但是a是一直存在的
> ```



getTemp() 返回的右值本来在表达式语句结束后，其生命也就该终结了（因为是临时变量），而通过右值引用，该右值又重获新生，其生命期将与右值引用类型变量 a 的生命期一样，只要 a 还活着，该右值临时变量将会一直存活下去。实际上就是给那个临时变量取了个名字。

注意：这里 a 的类型是右值引用类型( int && )，但是如果从左值和右值的角度区分它，它实际上是个左值。因为可以对它取地址，而且它还有名字，是一个已经命名的右值。 



**2. 右值引用的作用**

右值引用是C++11中新增加的一个很重要的特性，<font color=blue>他主是要用来解决C++98/03中遇到的两个问题</font>：

- **第一个问题就是临时对象非必要的昂贵的拷贝操作；**
- **第二个问题是在模板函数中如何按照参数的实际类型进行转发。**

C++11中，右值引用就是对一个右值进行引用的类型。由于右值通常不具有名字，所以我们一般只能通过右值表达式获得其引用，比如：

```C++
T && a=ReturnRvale(); // ReturnRvale()函数返回的是一个右值（也就是一个临时变量）
```

ReturnRvalue()函数返回一个右值，那么上述语句声明了一个名为a的右值引用，其值等于ReturnRvalue函数返回的临时变量的值。



**3. 右值引用的特点**

- 右值引用的第一个特点：通过右值引用的声明，右值又“重获新生",其生命周期与右值引用类型变量的生
  命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。
- 右值引用的第二个特点：右值引用独立于左值和右值。也就是说右值引用类型的变量可能是左值也可能
  是右值。 
- 右值引用的第三个特点： T&& t在发生自动类型推断的时候，它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。 [只有发生自动类型推断的时候才是，函数模板的类型自动推导，或auto关键字。

## 30. 堆和自由存储区的区别

堆是C的概念，自由存储区是C++的概念，两者在概念上有根本的不同，但C++沿袭了C，实际使用的是一块空间

## 31 传指针和传引用的适用场景

- 需要返回函数内局部变量的内存的时候用指针。
- 对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小 
- 类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式

## 32. 堆和栈的区别

1）申请方式：

栈由系统自动分配和管理，堆由程序员手动分配和管理。

2）效率：

栈由系统分配，速度快，不会有内存碎片。

堆由程序员分配，速度较慢，可能由于操作不当产生内存碎片。

3）扩展方向

栈从高地址向低地址进行扩展，堆由低地址向高地址进行扩展。

4）程序局部变量是使用的栈空间，new/malloc动态申请的内存是堆空间，函数调用时会进行形参和返回值的压栈出栈，也是用的栈空间。

## 33. 堆快还是栈快

**栈快一点**。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。

而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。

## 34. sizeof的使用

- 一个类中定义一个虚函数`virtual fun()`，那么这个类的大小是4(因为虚函数的实现是利用虚函数表和虚指针，类的大小就是指针的大小)
- 空类的大小为1
- static定义的变量不占用类的大小，普通函数也不占用类的大小

## 35. 红黑树如何保持平衡

> 1. [红黑树（2）保持平衡的根本套路](https://blog.csdn.net/mottohlm/article/details/81604069)

左旋、右旋和变颜色。

## 36. 结构体内存对齐的方式和为什么要进行内存对齐

**为什么要进行内存对齐**
因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，由于CPU读取数据是按块读取的，内存对齐可以使得CPU一次就可以将所需的数据读进来。

**对齐的方式**

- 第一个成员在与结构体变量偏移量为0的地址

- 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。 

- 对齐数=编译器默认的一个对齐数 与 该成员大小的较小值。 

- linux 中默认为4 

- vs 中的默认值为8
  结构体总大小为最大对齐数的整数倍（每个成员变量除了第一个成员都有一个对齐数）

## 37. inline关键字以及他和宏的区别

inline是内联的意思，可以定义比较小的函数。因为函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数。编译器会在编译阶段将代码体嵌入内联函数的调用语句块中 。

## 38. 成员初始化列表以及优势

成员初始化列表就是在类或者结构体的构造函数中，在参数列表后以冒号开头，逗号进行分隔的一系列初始化字段。

```C++
class A{
int id;
string name;
FaceImage face;
A(int& inputID,string& inputName,FaceImage& inputFace):id(inputID),name(inputName),face(inputFace){} // 成员初始化列表
};
```

因为<font color=blue>使用成员初始化列表进行初始化的话，**会直接使用传入参数的拷贝构造函数进行初始化，省去了一次调用默认构造函数的过程。所以使用成员初始化列表效率会高一些**。</font>

另外，有三种情况是必须使用成员初始化列表进行初始化的：

- 常量成员 (const) 的初始化，因为常量成员只能初始化不能赋值
- 引用类型
- 没有默认构造函数的对象必须使用成员初始化列表的方式进行初始化

## 39. C++的4种强制类型转换

四种强制类型转换操作符分别为：static_cast、dynamic_cast、const_cast、reinterpret_cast

## 40. 一个函数或者可执行文件的生成过程或者编译过程是怎样的

预处理，编译，汇编，链接

- 预处理： 对预处理命令进行替换等预处理操作
- 编译：代码优化和生成汇编代码
- 汇编：将汇编代码转化为机器语言
- 链接：将目标文件彼此链接起来

## 41. 声明和定义的区别

- 声明是告诉编译器变量的类型和名字，不会为变量分配空间

  int a; 声明一个变量a

- 定义就是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次

  int a=3; // 定义一个变量a

## 42. typde和define的区别

-  #define是预处理命令，在预处理是执行简单的替换，不做正确性的检查

-  typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名

## 43. 被free回收的内存是立即返还给操作系统吗？为什么

不是的，被free回收的内存会首先被 ptmalloc 使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。

## 44. 引用作为函数参数以及返回值的好处

1）在函数内部可以对此参数进行修改
2）提高函数调用和运行的效率（因为没有了传值和拷贝的时间、空间消耗）

<font color=blue>**用引用作为返回值最大的好处就是在内存中不产生被返回值的拷贝**。</font>
但是有以下的限制：
1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁；
2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成内存泄漏；
3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。



## 45. 友元函数和友元类

类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

```C++
#include <iostream>
using namespace std;
 
class Box{
   double width;
public:
   friend void printWidth( Box box );
   void setWidth( double wid );
};

// 成员函数定义
void Box::setWidth( double wid ){
    width = wid;
}
 
// 请注意：printWidth() 不是任何类的成员函数
void printWidth( Box box ){
   /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */
   cout << "Width of box : " << box.width <<endl;
}
 
// 程序的主函数
int main( ){
   Box box;
   box.setWidth(10.0); // 使用成员函数设置宽度
   printWidth( box ); // 使用友元函数输出宽度
   return 0;
}
```



## 46.  STL中的sort()算法是用什么实现的，stable_sort()呢

- sort算法是用快排和插入排序结合的方法实现的

- stable_sort()是归并排序。

## 47. vector的迭代器会失效吗

**会失效**

- 当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，begin和end迭代器都失效。
- 当vector在插入的时候，end迭代器肯定会失效 
- 当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。

## 48. 如何判断大端小端

字节序是对象在内存中存储的方式，大端即为最高有效位在前面，小端即为最低有效位在前面。

判断大小端的方法：使用一个union数据结构

```C++
union{
  short s;
  char c[2]; // sizeof(short)=2;
}un;
un.s=0x0102;
if(un.c[0]==1 and un.c[1]==2) cout<<"大端";
if(un.c[0]==2 and un.c[1]==1) cout<<"小端";
```

## 49. 如何使得类只在堆上或者栈上开辟空间

> 1. [只在堆上或者栈上开辟空间](https://blog.csdn.net/u011857683/article/details/81837879)

**1. 只在堆上**

**将析构函数设为私有，类对象就无法建立在栈上了**，只能在堆上开辟空间。

```C++
class A  {  
public:  
    A(){}  
    void destory(){delete this;}  
private:  
    ~A(){}  
};  
```

**2. 只在栈上**

只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。虽然你不能影响new operator的能力（因为那是C++语言内建的），但是你可以利用一个事实：new operator 总是先调用 operator new，而后者我们是可以自行声明重写的。因此，**将operator new()设为私有即可，禁止对象被new在堆上**。

```C++
class A  
{  
private:  
    void* operator new(size_t t){}    // 注意函数的第一个参数和返回值都是固定的  
    void operator delete(void* ptr){} // 重载了new就需要重载delete  
public:  
    A(){}  
    ~A(){}  
}; 
```



## 50. C++11新特性

- **空指针常量 nullptr**

  一个函数重载了空指针和整型的情形下，NULL并不能表示空指针，就有可能会出现错误，但是nullptr可以保证在任何情况下都是空指针。

- **自动类型推断 auto**

- **匿名函数**lambda

- **后置返回类型（tailng-return-type）**

- **long long int类型**

- **新增基于范围的for循环**

- 右值引用



## 51. 哪些数据会影响类的大小（sizeof）

```C++
class classSize{ // 空类的大小是1
    static int a; // 静态变量占用0空间
    const static int b=1; // 静态常量占用0空间
    const int c=0; // 常量占用4空间
    int * ptr=nullptr; // 指针占用4空间
    virtual int getRes(){ return 0;} // 虚函数占用4空间
    int getRes1(){int c=0; return 0;} // 一般函数占用0空间
    int d=3; // 变量占用4空间
};
```

常量、成员变量、虚函数、定义空类时类本身占用一个空间大小

## 52. vector中的clear和resize会回收内存吗？

只能清空数据，不会回收内存。

> 如何回收vector所占用的内存空间？
>
> 先使用vecInt.clear()清空, 再使用swap,释放空间回收内存. (先vec.clear()再vec->swap( (std::vector <temp>)(vec) )，就能实现清空vector和释放原来vector的内存)

## 53. 定义一个空类会自动生成哪些成员函数

- 缺省的(无参数的)构造函数
- 拷贝构造函数
- 析构函数
- 赋值运算符
- 取址运算符
- const版本的取址运算符

## 54. 拷贝构造函数和赋值运算符

```C++
class Person{
public:
	Person(){}
	Person(const Person& p){
		cout << "Copy Constructor" << endl;
	}

	Person& operator=(const Person& p){
		cout << "Assign" << endl;
		return *this;
	}

private:
	int age;
	string name;
};

void f(Person p){
	return;
}

Person f1(){
	Person p;
	return p;
}

int main(){
	Person p;
	Person p1 = p;    // 1
	Person p2;
	p2 = p;           // 2
	f(p2);            // 3

	p2 = f1();        // 4

	Person p3 = f1(); // 5

	getchar();
	return 0;
}
```



## 55. 传参、传指针、传引用的区别

**传值：**传值就是实参的拷贝传递给形参，但是两者相互独立，对形参的修改就不会影响到实参。

**传地址：**传地址就是把实参的地址复制给形参。对形参地址的修改不会影响到实参, 但是对形参地址所指向对象的修改却直接反应在实参中。

**传引用：**传引用本质没有任何实参的拷贝，一句话，就是让另外一个变量也执行该实参。就是两个变量指向同一个对象。这是对形参的修改，必然反映到实参上。

```C++
#include<bits/stdc++.h>
using namespace std
 
void adjustNum(int a){
    a++;
    return;
}

void adjustNum_ptr(int *a){
    (*a)++;
    return;
}

void adjustNum_addr(int &a){
    a++;
    return;
}

int main(){
    int b = 1;
    adjustNum(b); // 输出1
    adjustNum_ptr(&b) // 输出2；
    adjustNum_addr(b) // 输出2；
    cout << b << endl;
    return 0；
}
```





## 56. 智能指针

> 1. [C++11中智能指针的原理、使用、实现](https://www.cnblogs.com/wxquare/p/4759020.html)

智能指针和普通指针类似，只是不需要手动释放指针，而是通过智能指针自己管理内存的释放，**智能指针可以很好的避免内存泄漏的问题**。 智能指针包括：**auto_ptr、共享指针(shared_ptr)、弱指针（weak_ptr）和独占指针（unique_ptr）**

- **unique_ptr(独占指针)**

  ![转移 unique_ptr 的所有权](https://i-msdn.sec.s-msft.com/dynimg/IC786112.jpeg)

  - Unique_ptr是一个独占的智能指针，他不允许其他的智能指针共享其内部的指针，不允许通过赋值将一个unique_ptr赋值给另外一个 unique_ptr。
  - unique_ptr不允许复制，但可以通过函数返回给其他的unique_ptr，还可以通过move来转移到其他的unique_ptr，这样它本身就不再拥有原来指针的所有权了。
  - 如果希望只有一个智能指针管理资源或管理数组就用unique_ptr，如果希望多个智能指针管理同一个资源就用shared_ptr。

  ```C++
  #include<bits/stdc++.h>
  using namespace std;
  
  // 使用举例
  void useExample(){
      //创建一个指向int的空指针
      std::unique_ptr<int> fPtr1;
      std::unique_ptr<int> fPtr2(new int(4));
      auto fPtr3 = std::make_unique<int>();
      
      //fPtr2释放指向对象的所有权，并且被置为nullptr
      std::cout << "fPtr2 release before:" << fPtr2.get() << std::endl;
      int *pF = fPtr2.release();
      std::cout << "fPtr2 release after:" << fPtr2.get() << " and pF value:" << *pF << std::endl;
      
      //所有权转移，转移后fPtr3变为空指针
      std::cout << "move before fPtr1 address:" << fPtr1.get() << " fPtr3 address:" << fPtr3.get() << std::endl;
      fPtr1 = std::move(fPtr3);
      std::cout << "move after  fPtr1 address:" << fPtr1.get() << " fPtr3 address:" << fPtr3.get() << std::endl;
  
      std::cout << "move before fPtr1 address:" << fPtr1.get() << std::endl;
      fPtr1.reset();
      std::cout << "move after  fPtr1 address:" << fPtr1.get() << std::endl;
      
  }
  
  unique_ptr<int> clone(int p)
  {
      unique_ptr<int> pInt(new int(p));
      return pInt;    // 返回unique_ptr
  }
  
  int main()
  {
      // 1. 创建一个unique_ptr实例
      unique_ptr<int> pInt(new int(5));
      cout << "pInt1: " << *pInt << endl;
  
      // 2. unique_ptr不可以复制和拷贝
      // unique_ptr<int> pInt2(pInt);    // 报错
      // unique_ptr<int> pInt3 = pInt;   // 报错
  
      // 3. unique_ptr可以进行移动
      unique_ptr<int> pInt2 = move(pInt);    // 转移所有权
      // cout << *pInt << endl; // 出错，pInt为空
      cout << "pInt2: " << *pInt2 << endl;
      unique_ptr<int> pInt3(move(pInt2));
      cout << "pInt3: " << *pInt3 << endl;
  
      // 4. 可以作为返回对象返回
      unique_ptr<int> res = clone(6);
      cout << "result of function: " << *res << endl;
  
      useExample();
      return 0;
  }
  ```

  > 注意：
  >
  > - release和reset的区别：前者会释放控制权，返回裸指针，你还可以继续使用。而后者直接释放了指向对象。

- **shared_ptr(共享指针)**

  > 1. [shared_ptr的用法](https://www.cnblogs.com/jiayayao/p/6128877.html)

  shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。

  > 注意事项：
  >
  > 1. 不要用一个原始指针初始化多个shared_ptr。 
  > 2. 不要在函数实参中创建shared_ptr，在调用函数之前先定义以及初始化它。 
  > 3. 不要将this指针作为shared_ptr返回出来。 
  > 4. 要避免循环引用。

  ```C++
  # include<bits/stdc++.h>
  using namespace std;
  
  class Person{
  public:
      Person(int v) { // 构造函数
          value = v;
          cout << "Cons" <<value<< endl;
      }
      ~Person() { // 析构函数
          cout << "Des" <<value<< endl;
      }
      int value;
  };
  
  
  int main(){
      shared_ptr<Person> p1(new Person(1));// Person(1)的引用计数为1
      shared_ptr<Person> p2 = make_shared<Person>(2);
      // std::shared_ptr<int> p4 = new int(1);// error
  
      p1.reset(new Person(3));// 先生成新对象，然后引用计数减1，引用计数为0，故析构Person(1)
                              // 最后将新对象的指针交给智能指针
      shared_ptr<Person> p3 = p1;//现在p1和p3同时指向Person(3)，Person(3)的引用计数为2
      p1.reset();//Person(3)的引用计数为1
      p3.reset();//Person(3)的引用计数为0，析构Person(3)
      return 0;
  }
  ```

  

- **weak_ptr（弱指针**）

  weak_ptr是弱智能指针对象，它不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的智能指针。将一个weak_ptr绑定到一个shared_ptr对象，不会改变shared_ptr的引用计数。一旦最后一个所指向对象的shared_ptr被销毁，所指向的对象就会被释放，即使此时有weak_ptr指向该对象，所指向的对象依然被释放。

  weak_ptr是用来监视shared_ptr的，不会使引用计数加一，它不管理shared_ptr内部的指针，主要是为了监视shared_ptr的生命周期。 weak_ptr没有重载运算符*和->，因为它不共享指针，不能操作资源，主要是为了通过shared_ptr获得资源的监测权，它的构造不会增加引用计数，它的析构不会减少引用计数，纯粹只是作为一个旁观者来监视shared_ptr中关联的资源是否存在。 weak_ptr还可以用来返回this指针和解决循环引用的问题。

> 什么是循环引用
>
> 内存的正常回收：
>
> ![img](https://upload-images.jianshu.io/upload_images/2118879-1f06c66f210fb3e3.png?imageMogr2/auto-orient/strip|imageView2/2/w/472/format/webp)

>  循环引用导致的内存泄漏：
>
>  ![img](https://upload-images.jianshu.io/upload_images/2118879-09fed596c7d95b42.png?imageMogr2/auto-orient/strip|imageView2/2/w/443/format/webp)
>
>  



## 57. 库函数和系统调用的区别

- 库函数是语言或应用程序的一部分，而系统调用是操作系统的一部分；
- 库函数在用户态，系统调用在内核态；
- 库函数属于过程调用，开销比较小，但是系统调用需要在用户空间和内核上下文环境间切换，开销较大；

## 58. 构造函数调用虚函数调用谁的

调用自己的

## 59. 析构函数调用虚函数调用谁的



## 60. 类是先开辟空间还是先调用构造函数

先开辟空间，构造函数只是初始化这片空间

## 61. 何时调用析构函数

- 对象生命周期结束，被销毁时。也就是超出变量作用域；
- 主动调用delete ；
- 对象A是对象B的成员，B的析构函数被调用时，对象A的析构函数也被调用。

## 62. 源码到可执行文件的过程

<font color=blue>1）预编译</font>

主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下

1、删除所有的#define，展开所有的宏定义。

2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。

3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。

4、删除所有的注释，“//”和“/**/”。

5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。

6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。

<font color=blue>2）编译</font>

把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。

1、词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。

2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。

3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。

4、优化：源代码级别的一个优化过程。

5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。

6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。

<font color=blue>3）汇编</font>

将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。

<font color=blue>4）链接</font>

将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：

1、静态链接：

函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。

空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；

更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。

运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。

2、动态链接：

动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。

共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；

更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。

性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。



## 63. STL的基本组成

- STL主要由：以下几部分组成：容器、迭代器、仿函数、算法、分配器、配接器
- 他们之间的关系：分配器给容器分配存储空间，算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数

## 64. 静态函数和虚函数的区别

静态函数是在编译时确定运行的时机，但是虚函数是在运行时动态绑定。并且虚函数是使用了虚函数表机制。调用的时候会增加一次内存的开销。

## 65. C++是如何定义常量的，常量存储在什么位置

添加一个const限定就可以定义一个常量

局部对象存储于栈区，全局对象存储在全局/静态变量区，对于字面值常量，常量存放在常量存储区



## 66. 静态变量什么时候初始化

静态变量的初始化是在编译期确定的。

> 静态变量存储在虚拟地址空间的数据段和bss段，C语言中其在代码执行之前初始化，属于编译期初始化。而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造。



## 67. 什么时候会发生段错误

- 使用野指针
- 尝试对常量进行修改

## 68. 如何判断内存泄漏

- Linux下可以使用专门的工具Valgrind进行检测
- 可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。

## 69. map和set的区别

map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。

**map和set区别在于：**

- map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。

- set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key

  >  其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。

- map支持下标操作，set不支持下标操作。

  > map可以用key做下标

## 70. 智能指针有没有内存泄漏的情况

有，循环引用会导致内存泄漏。当两个对象，对象1中使用指针指向对象2，对象2使用指针指向1就导致了循环引用。解决循环引用可以使用weak_ptr.



## 71. strlen 和sizeof的区别

- strlen 是计算字符串的长度的，以‘\0’为结尾；sizeof是分配的数组实际所占的内存空间大小，不受里面存储内容的影响。
- strlen是一个函数，sizeof是运算符

> sizeof()是运算符，由于在编译时计算，因此sizeof不能用来返回动态分配的内存空间的大小。实际上，
> 用sizeof来返回类型以及静态分配的对象、结构或数组的空间，返回值跟这些里面所存储的内容没有关
> 系。
> 具体而言，当参数分别如下时，sizeof返回的值含义如下：
> 数组-编译时分配的数组空间大小
> 指针-存储该指针所用的空间大小
> 类型-该类型所占的空间的大小
> 对象-对象的实际占用空间大小
> 函数-函数返回类型所占空间的大小 



## 72. STL各种容器的底层实现

- vector： 数组  [在插入位置和删除位置之后的所有的迭代器和指针引用都会失效，扩容之后也是]

- map、multimap： 红黑树实现。红黑树中的元素为 pair<K, V> 实现以key为序排列。map 和
  multimap是有序

- unordered_map 和 unordered_multimap 是无序的，底层用hash table

- set 、multiset：和map的区别在于map中存储的是<key, value>,而set可以理解为关键字即值，也
  就是只保存关键字的容器。理解了这个，set multiset的实现与map 的底层实现一样，都是采用红
  黑树有序存储元素。
- unordered_set、unordered_multiset 底层实现为hash table。

- priority_queue（优先级队列） 相当于一个有权值得单向队列，在这个队列中，所有元素都是按照优先级排列得。 根据堆得处理规则来调整元素之间的位置，取出最大最小元素的时间复杂度为O(1)，插入和删除最坏的情况为O(logn)。

- list的底层数据结构为双向链表，特点是支持快速的增删。

- queue为单向队列，为先入先出原则。

- deque 为双向队列，其对比queue可以在头尾两端高效的插入和删除操作。 

## 73. 类的空指针可以调用成员函数吗

**可以**，正常情况下调用时编译器会默认将this指针作为参数传递过去，这种情况下，传递的this指针为空，参数为空不影响函数的调用。但是如果在执行的时候使用了成员变量，也就是会出现null->data，程序就会崩溃。 

```C++
class  CNullPointCall
{
public :
     static   void  Test1();
     void  Test2();
     void  Test3( int  iTest);
     void  Test4();

private :
     static   int  m_iStatic;
     int  m_iTest;
};

int  CNullPointCall::m_iStatic  =   0 ;

void  CNullPointCall::Test1()
{
    cout  <<  m_iStatic  <<  endl;
}

void  CNullPointCall::Test2()
{
    cout  <<   " Very Cool! "   <<  endl; 
}

void  CNullPointCall::Test3( int  iTest)
{
    cout  <<  iTest  <<  endl; 
}

void  CNullPointCall::Test4()
{
    cout  <<  m_iTest  <<  endl; 
}

int main(){
    CNullPointCall  * pNull  =  NULL;  //  定义一个类的空指针
    pNull -> Test1(); //  call 1
    pNull -> Test2();  //  call 2
    pNull -> Test3( 13 );  //  call 3
    pNull -> Test4(); / /  call 4
}
```



## 74. 数组和指针的区别

- 赋值：
  同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝。
- 存储方式
  - 数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下标进行访问的；
    多维数组在内存中是按照一维数组存储的，只是在逻辑上是多维的；
    数组的存储空间，不是在静态区就是在栈上；
  - 指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。
    指针：由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确
    定。
- 求sizeof
  数组
  数组所占存储空间的内存：sizeof（数组名字）
  数字的大小 sizeof(数组名) / sizeof(数据类型)
  指针：
  在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指
  针的类型是什么，sizeof（指针名）都是8。
- 传参
  数组传参：将整个数组拷贝一份传入函数时，将数组名看做常量指针，传数组元素的地址。 

## 75. C++哪类函数不可以设计为虚函数

> <font color=blue>不能是虚函数的函数：静态成员函数、内联函数、构造函数</font>

设置虚函数须注意：
1：只有类的成员函数才能说明为虚函数；
**2：静态成员函数不能是虚函数；**
**3：内联函数不能为虚函数；**
**4：构造函数不能是虚函数；**
5：析构函数可以是虚函数，而且通常声明为虚函数。

虚函数可以实现多态，那么那些函数不能申明为虚函数呢？

1.普通的函数

因为普通函数只能被overload，不能被override，也不能被继承，所以在编译的时候就绑定函数，所以不能申明为virtual，没有意义！

2.构造函数

这个也很简单。主要因为构造函数是用来确定初始化对象的，而virtual主要是为了在不了解具体的情况下实现动态绑定，调用不同类型中合适的成员函数而存在的，现在对象都没产生，怎么能实现多态呢。一个是为了具体化，一个是为了在不同对象类型中确定合适的函数，这是不可能的！

此外，构造函数不能被继承，所以不能virtual；构造函数是系统默认提供或者自己写的，并且和类名相同，就算继承了也不是自己的了，所以不能被继承；

构造函数是在为了创建初始化对象存在的，对象不存在实现多态是不可能的；

3.内联函数

inline函数在编译时被展开，在调用处将整个函数替换为代码块，省去了函数跳转的时间，提高了SD，减少函数调用的开销，虚函数是为了继承后对象能够准确的调用自己的函数，执行相应的动作。

主要的原因是：inline函数在编译时被展开，用函数体去替换函数，而virtual是在运行期间才能动态绑定的，这也决定了inline函数不可能为虚函数。（inline函数体现的是一种编译机制，而virtual体现的是一种动态运行机制）

4.静态成员函数

静态成员函数是类的组成部分，但是不是任何对象的组成部分，所有对象共享一份，没有必要动态绑定，也不能被继承【效果能，但机理不能。静态成员函数就一份实体，在父类里；子类继承父类时也无需拷贝父类的静态函数，但子类可以使用父类的静态成员函数】，并且静态成员函数只能访问静态变量。所以不能为virtual。

5.友员函数

友员函数不是类的成员函数，C++不支持友员被继承，所以不能为virtual。